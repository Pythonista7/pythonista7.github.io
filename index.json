[{"content":"In this blog I would like to talk about how to get started with FFmpeg by making zero assumptions about what you already know.If you already know about all its nitty-gritties then this may not be for you, but if you haven\u0026rsquo;t trust me you are gonna love what it has to offer for likes of media processing.\nWhat\u0026rsquo;s in the name ? Let\u0026rsquo;s get the elephant out of the way if , wether you\u0026rsquo;ve already heard of ffmpeg or not, you must\u0026rsquo;ve wondered what it stand\u0026rsquo;s for? Well, it was inspired from the famous MPEG with Fast-Forward preprended to it.\nWhat is it? Often called the Swiss Army knife of media tools ,FFmpeg lives up to the name. It is a framework that lets to perform almost any media manipulation tasks you can think of, allowed for by the plethora of features housed inside it. To probe a level deeper, FFmpeg is used as binary which is an ensemble of various media processing libraries such as libavcodec , libavformat , libavdevice etc packaged into a single executable.\nEverything from media conversions to splitting streams to running a RTMP server is made possible just by passing in a few command-line args! (we will see more about its capabilities in the What can it do? section).And yes its FOSS !\nHow can I get it ? You can download it from the official page or from ffbinaries. I would like to give a shout-out here to johnvansickle.com who host\u0026rsquo;s numerous static ffmpeg build\u0026rsquo;s for free under GPL3 ! Do checkout his FAQ section to know more about ffmpeg static builds .\nWhat can it do? FFmpeg is an extremely versatile tool, thought its mostly thought of as a media-conversion tool to convert between different formats and codec\u0026rsquo;s ( as below ) it is capable of much much more which we will get to soon! If you are willing to deep-dive into ffmpeg I suggest you take a look at the basic format of ffmpeg command here.\nFor Transcoding Lets input a media file using -i which indicate\u0026rsquo;s that the next argument is the input.Say for example I wanted to covert a .webm video to .mp4 the ffmpeg command would look something like this.\nffmpeg -i path/to/my-video.webm path/to/converted-video.mp4 That\u0026rsquo;s it! no more hunting for that media-converter that download\u0026rsquo;s all sorts of garbage onto your machine.\nCombining Video and Audio Ever wanted to add some background music to some of your favorite memories but all video editing tools are just too complex for something as simple as this ? FFmpeg to the rescue , you can do this with a one-line.\nffmpeg -i \u0026lt;PATH-TO-INPUT-VIDEO\u0026gt; -i \u0026lt;PATH-TO-INPUT-AUDIO\u0026gt; -c:v \u0026lt;VIDEO-CODEC\u0026gt; -c:a \u0026lt;AUDIO-CODEC\u0026gt; \u0026lt;PATH-TO-OUTPUT-FILE\u0026gt; Here -c is a alias for -codec which specifies the media-codec you want to use in the operation, -c:v specifies that you are selecting a codec for the video stream , you can specify any one listed from running :\n $ ffmpeg -codecs or use copy which re-uses the stream as is (without re-encoding) it.\nFor example , lets say we want to combine a mp4 and wav the command would look like this :\nffmpeg -i video.mp4 -i audio.wav -c:v copy -c:a aac output.mp4 Simple right? But wait,there is more!\nLet\u0026rsquo;s say you wanted to perform a series of operations , perhaps you wanted to first crop a video and then flip it and then overlay it back on the original video(essentially a mirror effect), can ffmpeg perform such complex sequence of tasks? Hell yes\nFFmpeg Filter Graph Let\u0026rsquo;s say our goal was to write a ffmpeg command to vertically mirror a video ,meaning the bottom half must be a mirror image of the top half.Lets cut to the chase and take a look at the cmd right up, but dont be intimidated we are going the breakdown and understand each aspect of it below.\nffmpeg -i \u0026lt;INPUT-VIDEO\u0026gt; -vf \u0026quot;split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip];[main][flip] overlay=0:H/2\u0026quot; \u0026lt;OUTPUT-VIDEO\u0026gt; Before we start to breakdown this ffmpeg command , lets try to get an idea of how to visualize such \u0026ldquo;filters\u0026rdquo; , the way one would go about the task mentioned previously would be as below :\n ┌──────────┐ │ │ ┌────────┐ main │ overlay │ │ │ ┌─────────────────────────────────────────────────────┤ filter ├────►│ Output │ │ │ │ │ Video │ │ └─────┬────┘ │ │ │ │ └────────┘ ┌───────────┐ ┌─────┴──────┐ │ │ │ │ │ │ │ Input │ │ split │ │ │ Video ├───────►│ filter │ │ │ │ │ │ │ └───────────┘ └─────┬──────┘ │ │ │ │ │ │ │ │ ┌──────────┐ ┌───────────┐ │ │ │ │ │ │ │ └──────────────────►│ crop ├─────►│ vflip ├─────────┘ tmp │ filter │ │ filter │ └──────────┘ └───────────┘ Ok so now lets break this down , -vf \u0026quot;split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip];[main][flip] overlay=0:H/2\u0026quot;\nBasic Filter -vf is the cmd arg used to indicate that we want to perform a filter operation , i.e : video filter. ffmpeg also supports audio filter which can be used with -af. Alternatively , filters can also be initialized with -filter or -filter_complex.\n-vf is followed by a string that represents the filter-graph definition consisting of the series of filers to be used and their respective inputs and outputs. The syntax for defining the filter string is as follows :\n\u0026quot;[input-stream-1][input-stream-2](...more) \u0026lt;FILTER-NAME\u0026gt; [output-stream-1][output-stream-2](...more);\u0026quot; And dont worry you can rename the intermediate streams represented within the [] by any name you wish here I am using main, tmp and flip .\nIn out example we have used the following filters :\n split : split [main][tmp];  Split input into several identical outputs. input : \u0026lt; INPUT-VIDEO \u0026gt; output : tmp , main (here tmp and main are 2 new strams duplicated from the input)    Since split is defined as the first filter the input is automatically set to be the stream defined by -i in the ffmpeg command.\n crop :  [tmp] crop=iw:ih/2:0:0, vflip [flip];  Crop the input video to given dimensions. input : [tmp] params : crop=w=\u0026lt;width\u0026gt;:h=\u0026lt;height\u0026gt;:x=\u0026lt;x-position\u0026gt;:y=\u0026lt;y-position\u0026gt; , the param keys such as w=\u0026lt;width\u0026gt; etc. can be dropped and the same filter can be rewritten as crop=\u0026lt;width\u0026gt;:\u0026lt;height\u0026gt;:\u0026lt;x-position\u0026gt;:\u0026lt;y-position\u0026gt;     In this step we notice we 2 things, one being the crop filter contains what seems to look like a variable in wi and hi , and indeed they are. wi and hi are input-width and input-height defined by ffmpeg internally and ready for use anywhere within your filter. Secondly you notice that this filter is not terminated by a ; but seems to be extended with a , .This means that the output of the current filter is carried over to the next one without needing to redundantly name filter which would otherwise extend out command to look like this :\n\u0026quot; [tmp] crop=iw:ih/2:0:0 [tmp2] ; [tmp2] vflip [flip]; \u0026quot; here tmp2 is redundant , which as you can see both reduces the expressiveness and makes it a but cluttered.Hence when ever we wish to extend a sequence of filter where one output leads into another input we can just follow such filters with a , .\n overlay : [main][flip] overlay=0:H/2  Overlay one video on top of another. input : two video stream in the order they are stacked , first stream would be the bg and second would be fg params :  overlay=x=\u0026lt;x-position\u0026gt;:y=\u0026lt;y-position\u0026gt; , x and y default to 0. output : single video stream with both the videos over-layed.    Just like how the first filter did not mandate to specify the input stream the last filter also automatically assumes that the output of the last filter is the output that gets written to the specified \u0026lt; OUTPUT-FILE \u0026gt;.\nHere again you notice a variable H , in the overlay filter we have access to the height and width of 2 videos, foreground and background , represented respectively by lowercase and uppercase h/H and w/W (read more) . Hence here we specify that we wish to overlay flip over main to occupy half the total height of main by specifying the y to be H/2 .\nAnd we\u0026rsquo;re done!\n   Original Vertically Mirrored         video credits      Boom! Video editing with 0 GUI !\nImpressive isn\u0026rsquo;t it , I hope this de-stigmatized cli tools for the readers in general as they are very useful and effective when you know what exactly you want to do. Definitely FFmpeg is capable of lot more , if you like this blog i would highly suggest you to checkout the official docs if you plan on writing your own ffmpeg pipelines. What we covered here is just the tip of the iceberg ffmpeg has a variety of filters which can be used to assembly extremely complex filter graphs to perform any video editing task one would normally need (especially the repetitive one\u0026rsquo;s). Here is a link some of the \u0026quot;\u0026quot; fancy stuff \u0026quot;\u0026quot; ffmpeg comes with.\nCheers and Happy Learning !\n","permalink":"https://examplesite.com/blog/ffmpeg/","summary":"In this blog I would like to talk about how to get started with FFmpeg by making zero assumptions about what you already know.If you already know about all its nitty-gritties then this may not be for you, but if you haven\u0026rsquo;t trust me you are gonna love what it has to offer for likes of media processing.\nWhat\u0026rsquo;s in the name ? Let\u0026rsquo;s get the elephant out of the way if , wether you\u0026rsquo;ve already heard of ffmpeg or not, you must\u0026rsquo;ve wondered what it stand\u0026rsquo;s for?","title":"Video Editing Without a GUI"}]